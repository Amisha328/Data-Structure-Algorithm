// Minimize Malware Spread
// Problem link:
// https://leetcode.com/problems/minimize-malware-spread/

// problem tags: 
// Using Union Set

#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    int findPar(int node, vector<int> &parent){
        if(node == parent[node]) return node;
        // path compression
        return parent[node] = findPar(parent[node], parent);
    }
    void unionn(int p1, int p2, vector<int> &parent, vector<int> &size){
        if(size[p1] > size[p2]){
            parent[p2] = p1;
            size[p1] += size[p2];
        }
        else{
            parent[p1] = p2;
            size[p2] += size[p1];
        }
    }
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        // Using Union Set 
        vector<int> parent(n);
        vector<int> size(n, 1);
        for(int i = 0; i < n; i++)
            parent[i] = i;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                // if there is a direct link between i and j
                if(graph[i][j] == 1) {
                    int p1 = findPar(i, parent);
                    int p2 = findPar(j, parent);
                    
                    if(p1 != p2)
                        unionn(p1, p2, parent, size);    
                }
            }
        }
        
        // if in the initial array there are nodes that belong to the same group
        // then even if we remove one node the entire component remains infected due to other element
        // hence we will not remove the node from that component 
        // instead we can remove node from next larger sized component
        
        vector<int> infected(n); 
        // this keep count of number of infected node belonging to same component in initial array
        for(auto e: initial){
            int p = findPar(e, parent);
            infected[p]++;
        }
        
        int ans = -1;
        int maxSize = -1;
        for(auto e: initial){
            int p = findPar(e, parent);
            if(infected[p] == 1 && size[p] >= maxSize){
                if(maxSize == size[p]) // if two components have same size then a node with the smallest index is removed
                    ans = min(ans, e);
                else 
                    ans = e;
                maxSize = size[p];
            }
        }
        
        // ans remains -1 only if all the components have atleast 2 nodes in initial infected array
        // hence return the node with the smallest index
        if(ans == -1){
            int minn = INT_MAX;
            for(auto e: initial)
                minn = min(minn, e);
            return minn;
        }
        return ans;
    }
};