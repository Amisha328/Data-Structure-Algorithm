// Minimize Malware Spread II
// Problem link:
// https://leetcode.com/problems/minimize-malware-spread-ii/

// Problem tag: DFS

#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Using DFS
    void dfs(vector<vector<int>>& graph, set<int> &infected, int curr_node, int removed_node){
        // to store the infected nodes after a node is removed
        if(!infected.count(curr_node) && curr_node != removed_node){
            infected.insert(curr_node);
            for(int j = 0; j < graph[curr_node].size(); j++){
                if(graph[curr_node][j] == 1)
                    dfs(graph, infected, j, removed_node);
            }
        }      
    }
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        if(initial.size() == 1)
            return initial[0];
        
        int min_size = INT_MAX;
        int min_idx = 0;
        
        for(int i = 0; i < initial.size(); i++){
            set<int> infected; // stores all the infected nodes after the removal of the node
            for(int j = 0; j < initial.size(); j++){
                if(i != j){
                    // simulating that we are removing the node at initial[i]
                    // example:
                    // if initial = {2, 4, 6}
                    // then when we are at 2 dfs is called for 4 and 6
                    // when we are at 4 dfs is called for 2 and 6.
                    dfs(graph, infected, initial[j], initial[i]);
                }
            }
            
            // now check if the infected nodes size after the removal is less than the previously seen min size
            if(infected.size() < min_size){
                min_size = infected.size();
                min_idx = initial[i];
            }
            else if(infected.size() == min_size){
                // if the infected nodes size after the removal is equal to the previously seen min size
                min_idx = min(initial[i], min_idx);
            }  
        }
        return min_idx;
    }
};
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    /*
    int findPar(int node, vector<int> &parent){
        if(node == parent[node]) return node;
        // path compression
        return parent[node] = findPar(parent[node], parent);
    }
    void unionn(int p1, int p2, vector<int> &parent, vector<int> &size){
        if(size[p1] > size[p2]){
            parent[p2] = p1;
            size[p1] += size[p2];
        }
        else{
            parent[p1] = p2;
            size[p2] += size[p1];
        }
    }
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        // Using Union Set 
        vector<int> parent(n);
        vector<int> size(n, 1);
        for(int i = 0; i < n; i++)
            parent[i] = i;
        
        set<int> s;
        for(auto e: initial)
            s.insert(e);
        
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                // if there is a direct link between i and j
                // we will connect only those edges that are not present in the initial array
                if(graph[i][j] == 1 && s.find(i) == s.end() && s.find(j) == s.end()) {
                    int p1 = findPar(i, parent);
                    int p2 = findPar(j, parent);
                    
                    if(p1 != p2)
                        unionn(p1, p2, parent, size);    
                }
            }
        }
        
        vector<int> infected(n);
        // we will store the unique parents of the nodes present in initial infected array
        // we are taking set so that we don't include the two nodes belonging to same parent.
        map<int,set<int>> mp;
        for(int u: initial){
            for(int j = 0; j < n; j++){
                if(graph[u][j] == 1 && u !=j && s.find(j) == s.end()){
                    int p = findPar(j, parent);
                    if(mp.find(u) == mp.end()){
                        set<int> temp = mp[u];
                        if(temp.find(p) == temp.end())
                        {
                            mp[u].insert(p);
                            infected[p]++;
                        }
                    }
                }
            }
        }
        int ans = -1;
        int maxx = -1;
        for(int e: initial){
            set<int> par = mp[e];
            int tota = 0;
            for(int p: par)
                if(infected[p] == 1)
                    total += size[p];
            if(total >= maxx){
                if(total == maxx)
                    ans = min(ans,e);
                else
                    ans = e;
            }
            maxx = total;
        }
        if(ans == -1){
            int minn = INT_MAX;
            for(int e : initial){
                minn = min(minn, e);
            }
            return minn;
        }
        return ans;
    }
};
    */
